
import java.util.HashMap;
import java.util.Map;
import java.util.LinkedList;

/**
 * An implementation of <tt>Cache</tt> that uses a least-recently-used (LRU)
 * eviction policy.
 */
public class LRUCache<KeyType, ValueType> implements Cache<KeyType, ValueType> 
{	
	private final DataProvider _provider;
	private final int _capacity;
	private int _misses = 0;
	private HashMap<String, String> _data = new HashMap<String, String>();
	private LinkedList<KeyType> _dataKeys = new LinkedList<String>();

	public LRUCache (DataProvider<KeyType, ValueType> provider, int capacity) 
	{
		/*
		 * @param provider the data provider to consult for a cache miss
		 * @param capacity the exact number of (key, value) pairs to store in the cache
		 */
		_provider = provider;
		_capacity = capacity;
	}

	/**
	 * Returns the value associated with the specified key.
	 * @param key the key
	 * @return the value associated with the key
	 */	
	public ValueType get (KeyType key) 
	{
		if(_data.containsKey(key))
		{
			return (ValueType) _data.get(key);
		}
		else
		{
			if(_data.size() == _capacity)
			{
				eviction();
			}
			else
			{
				String value = (String) _provider.get(key);
				_dataKeys.add(key);
			}
		}
	}
	
	public void eviction()
	{
		
	}

	public int getNumMisses () 
	{
		/*
		 * Returns the number of cache misses since the object's instantiation.
		 * @return the number of cache misses since the object's instantiation.
		 */
		return _misses;
	}
}
